//------------------------------------------------------------------------------
// <auto-generated>
// CleanArchitecture.Blazor - MIT Licensed.
// Author: Claude Code (AI Assistant)
// Created: 2025-09-04
// GetIssueTimelineQuery: Query to retrieve timeline events for an issue
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
#nullable disable warnings

using AutoMapper;
using AutoMapper.QueryableExtensions;
using CleanArchitecture.Blazor.Application.Common.Interfaces;
using CleanArchitecture.Blazor.Application.Common.Interfaces.Identity;
using CleanArchitecture.Blazor.Application.Common.Models;
using CleanArchitecture.Blazor.Application.Features.Issues.Caching;
using CleanArchitecture.Blazor.Application.Features.Issues.DTOs;
using CleanArchitecture.Blazor.Domain.Entities;
using MediatR;
using Microsoft.EntityFrameworkCore;

namespace CleanArchitecture.Blazor.Application.Features.Issues.Queries.GetIssueTimeline;

public class GetIssueTimelineQuery : ICacheableRequest<Result<List<TimelineEventDto>>>
{
    public required Guid IssueId { get; set; }
    public string CacheKey => IssueCacheKey.GetTimelineCacheKey($"{IssueId}");
    public IEnumerable<string>? Tags => IssueCacheKey.Tags;
}

public class GetIssueTimelineQueryHandler : IRequestHandler<GetIssueTimelineQuery, Result<List<TimelineEventDto>>>
{
    private readonly IApplicationDbContextFactory _dbContextFactory;
    private readonly IMapper _mapper;
    private readonly IUserContextAccessor _userContextAccessor;
    
    public GetIssueTimelineQueryHandler(
        IApplicationDbContextFactory dbContextFactory,
        IMapper mapper,
        IUserContextAccessor userContextAccessor
    )
    {
        _dbContextFactory = dbContextFactory;
        _mapper = mapper;
        _userContextAccessor = userContextAccessor;
    }

    public async Task<Result<List<TimelineEventDto>>> Handle(GetIssueTimelineQuery request, CancellationToken cancellationToken)
    {
        await using var db = await _dbContextFactory.CreateAsync(cancellationToken);
        
        var currentUser = _userContextAccessor.Current;
        var currentTenantId = currentUser?.TenantId;
        
        // Check if issue exists and user has access
        var issueExists = await db.Issues
            .Where(i => i.Id == request.IssueId && i.TenantId == currentTenantId)
            .AnyAsync(cancellationToken);
            
        if (!issueExists)
        {
            return Result<List<TimelineEventDto>>.Failure("Issue not found or access denied.");
        }

        try
        {
            // Get event logs with user information
            var eventLogs = await db.EventLogs
                .Where(e => e.IssueId == request.IssueId && e.TenantId == currentTenantId)
                .Select(e => new TimelineEventDto
                {
                    Id = e.Id,
                    IssueId = e.IssueId,
                    Type = e.Type,
                    Description = e.Type, // Will be formatted in component
                    Payload = e.Payload,
                    Timestamp = e.CreatedUtc,
                    UserName = e.CreatedBy ?? "System",
                    UserId = e.CreatedBy
                })
                .ToListAsync(cancellationToken);

            // Get internal notes as timeline events
            var noteEvents = await db.InternalNotes
                .Where(n => n.IssueId == request.IssueId && n.TenantId == currentTenantId)
                .Select(n => new TimelineEventDto
                {
                    Id = n.Id,
                    IssueId = n.IssueId,
                    Type = "note_added",
                    Description = "Internal note was added",
                    Payload = n.Content,
                    Timestamp = n.CreatedAt,
                    UserName = n.CreatedBy ?? "Unknown User",
                    UserId = n.CreatedByUserId,
                    Details = n.Content.Length > 100 ? $"{n.Content.Substring(0, 100)}..." : n.Content
                })
                .ToListAsync(cancellationToken);

            // Get attachment events
            var attachmentEvents = await db.Attachments
                .Where(a => a.IssueId == request.IssueId && a.TenantId == currentTenantId)
                .Select(a => new TimelineEventDto
                {
                    Id = a.Id,
                    IssueId = a.IssueId,
                    Type = "attachment_added",
                    Description = "Attachment was added",
                    Payload = $"{{\"fileName\":\"{a.Type}\",\"size\":{a.SizeBytes}}}",
                    Timestamp = a.CreatedUtc,
                    UserName = a.CreatedBy ?? "System",
                    UserId = a.CreatedBy,
                    Details = $"{a.Type} ({FormatFileSize(a.SizeBytes)})"
                })
                .ToListAsync(cancellationToken);

            // Combine all timeline events
            var allEvents = new List<TimelineEventDto>();
            allEvents.AddRange(eventLogs);
            allEvents.AddRange(noteEvents);
            allEvents.AddRange(attachmentEvents);

            // Sort by timestamp descending
            var sortedEvents = allEvents
                .OrderByDescending(e => e.Timestamp)
                .ToList();

            return Result<List<TimelineEventDto>>.Success(sortedEvents);
        }
        catch (Exception ex)
        {
            return Result<List<TimelineEventDto>>.Failure($"Error retrieving timeline: {ex.Message}");
        }
    }

    private static string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }
}