@page "/agent-dashboard"
@using CleanArchitecture.Blazor.Application.Features.Conversations.DTOs
@using CleanArchitecture.Blazor.Application.Features.Conversations.Queries.GetEscalatedConversations
@using CleanArchitecture.Blazor.Application.Features.Conversations.Queries.GetAvailableAgents
@using CleanArchitecture.Blazor.Application.Features.Conversations.Commands.AssignAgent
@using CleanArchitecture.Blazor.Application.Features.Conversations.Commands.CompleteConversation
@using CleanArchitecture.Blazor.Application.Common.Security
@using Microsoft.AspNetCore.SignalR.Client
@using CleanArchitecture.Blazor.Server.UI.Hubs

@attribute [Authorize(Policy = Permissions.Conversations.ViewAgentDashboard)]

@inject IMediator Mediator
@inject ISnackbar Snackbar
@inject IJSRuntime JS
@inject NavigationManager Navigation
@implements IAsyncDisposable

<script src="~/js/notifications.js"></script>

<PageTitle>Agent Dashboard</PageTitle>

<MudContainer MaxWidth="MaxWidth.False" Class="pa-6">
    <div class="d-flex justify-space-between align-center mb-6">
        <div>
            <MudText Typo="Typo.h4" Class="mb-2">Agent Dashboard</MudText>
            <MudText Typo="Typo.body1" Class="mud-text-secondary">Real-time conversation escalation management</MudText>
        </div>
        <div class="d-flex align-center gap-4">
            <MudChip T="string" 
                    Icon="@GetConnectionIcon()" 
                    Color="@GetConnectionColor()" 
                    Size="Size.Small">
                @_connectionStatus
            </MudChip>
            <MudChip T="string" Icon="Icons.Material.Filled.AccessTime" Color="Color.Info" Size="Size.Small">
                Last Updated: @_lastUpdate.ToString("HH:mm:ss")
            </MudChip>
            <MudButton Variant="Variant.Outlined" 
                      StartIcon="Icons.Material.Filled.Refresh" 
                      OnClick="RefreshData" 
                      Size="Size.Small"
                      Disabled="@_isConnecting">
                Refresh
            </MudButton>
        </div>
    </div>

    <MudGrid>
        <!-- Agent Status Panel -->
        <MudItem xs="12" md="4">
            <MudPaper Class="pa-4" Style="height: 600px; overflow-y: auto;">
                <div class="d-flex align-center mb-4">
                    <MudIcon Icon="Icons.Material.Filled.Support" Class="mr-2"/>
                    <MudText Typo="Typo.h6">Available Agents (@_availableAgents.Count)</MudText>
                </div>
                
                @if (_loading)
                {
                    <MudProgressCircular Indeterminate="true" Class="ma-4"/>
                }
                else
                {
                    @foreach (var agent in _availableAgents.OrderByDescending(a => a.IsAvailable))
                    {
                        <MudCard Class="@($"mb-2 {(agent.IsAvailable ? "border-success" : "border-warning")}")">
                            <MudCardContent Class="pa-3">
                                <div class="d-flex justify-space-between align-center">
                                    <div>
                                        <MudText Typo="Typo.subtitle2" Class="mb-1">
                                            @(agent.DisplayName ?? agent.UserName)
                                        </MudText>
                                        <div class="d-flex align-center gap-2">
                                            <MudChip T="string" Size="Size.Small" Color="@GetStatusColor(agent.Status)">
                                                @agent.StatusText
                                            </MudChip>
                                            <MudText Typo="Typo.caption">
                                                @agent.ActiveConversationCount/@agent.MaxConcurrentConversations
                                            </MudText>
                                        </div>
                                    </div>
                                    <MudProgressCircular Value="@agent.WorkloadPercentage" 
                                                       Color="@GetWorkloadColor(agent.WorkloadPercentage)"
                                                       Size="Size.Small"/>
                                </div>
                            </MudCardContent>
                        </MudCard>
                    }
                }
            </MudPaper>
        </MudItem>

        <!-- Escalated Conversations -->
        <MudItem xs="12" md="8">
            <MudPaper Class="pa-4" Style="height: 600px;">
                <div class="d-flex align-center justify-space-between mb-4">
                    <div class="d-flex align-center">
                        <MudIcon Icon="Icons.Material.Filled.PriorityHigh" Class="mr-2 mud-error-text"/>
                        <MudText Typo="Typo.h6">Escalated Conversations (@_escalatedConversations.Count)</MudText>
                    </div>
                    <MudSwitch T="bool" @bind-Checked="_autoAssign" 
                              Label="Auto-assign" 
                              Color="Color.Primary"
                              Size="Size.Small"/>
                </div>

                @if (_loading)
                {
                    <div class="d-flex justify-center pa-8">
                        <MudProgressCircular Indeterminate="true" Size="Size.Large"/>
                    </div>
                }
                else if (!_escalatedConversations.Any())
                {
                    <div class="d-flex flex-column align-center justify-center pa-8">
                        <MudIcon Icon="Icons.Material.Outlined.CheckCircle" 
                                Style="font-size: 64px;" 
                                Class="mb-4 mud-success-text"/>
                        <MudText Typo="Typo.h6" Class="mb-2">All Clear!</MudText>
                        <MudText Typo="Typo.body2" Class="mud-text-secondary">
                            No escalated conversations at the moment.
                        </MudText>
                    </div>
                }
                else
                {
                    <div style="height: 500px; overflow-y: auto;">
                        @foreach (var conversation in _escalatedConversations)
                        {
                            <MudCard Class="@($"mb-3 {GetPriorityCardClass(conversation.Priority)}")">
                                <MudCardContent>
                                    <div class="d-flex justify-space-between align-start mb-2">
                                        <div class="flex-grow-1">
                                            <div class="d-flex align-center gap-2 mb-1">
                                                <MudText Typo="Typo.subtitle1">
                                                    ðŸ“± @(conversation.WhatsAppPhoneNumber ?? "Unknown Number")
                                                </MudText>
                                                @if (conversation.Priority > 1)
                                                {
                                                    <MudChip T="string" 
                                                            Size="Size.Small" 
                                                            Color="@GetPriorityColor(conversation.Priority)"
                                                            Icon="@GetPriorityIcon(conversation.Priority)">
                                                        @conversation.PriorityText
                                                    </MudChip>
                                                }
                                            </div>
                                            <MudText Typo="Typo.body2" Class="mb-2 mud-text-secondary">
                                                @conversation.EscalationReason
                                            </MudText>
                                            <div class="d-flex align-center gap-4 mb-2">
                                                <MudChip T="string" Size="Size.Small" 
                                                        Color="@GetModeColor(conversation.Mode)">
                                                    @conversation.ModeText
                                                </MudChip>
                                                <MudText Typo="Typo.caption">
                                                    Escalated: @conversation.EscalatedAt?.ToString("HH:mm")
                                                </MudText>
                                                <MudText Typo="Typo.caption">
                                                    Duration: @FormatDuration(conversation.Duration)
                                                </MudText>
                                            </div>
                                            @if (!string.IsNullOrEmpty(conversation.CurrentAgentName))
                                            {
                                                <MudAlert Severity="Severity.Info" Dense="true" Class="mb-2">
                                                    Assigned to: @conversation.CurrentAgentName
                                                </MudAlert>
                                            }
                                        </div>
                                        <div class="d-flex flex-column gap-1">
                                            @if (string.IsNullOrEmpty(conversation.CurrentAgentId))
                                            {
                                                <MudButton Variant="Variant.Filled" 
                                                          Color="Color.Primary" 
                                                          Size="Size.Small"
                                                          StartIcon="Icons.Material.Filled.Assignment"
                                                          OnClick="() => AcceptConversation(conversation)"
                                                          Disabled="_processing">
                                                    Accept
                                                </MudButton>
                                            }
                                            else
                                            {
                                                <MudButton Variant="Variant.Outlined" 
                                                          Color="Color.Success" 
                                                          Size="Size.Small"
                                                          StartIcon="Icons.Material.Filled.CheckCircle"
                                                          OnClick="() => CompleteConversation(conversation)"
                                                          Disabled="_processing">
                                                    Complete
                                                </MudButton>
                                            }
                                            <MudButton Variant="Variant.Text" 
                                                      Color="Color.Primary" 
                                                      Size="Size.Small"
                                                      StartIcon="Icons.Material.Filled.Chat"
                                                      OnClick="() => OpenConversation(conversation)">
                                                View
                                            </MudButton>
                                        </div>
                                    </div>
                                </MudCardContent>
                            </MudCard>
                        }
                    </div>
                }
            </MudPaper>
        </MudItem>
    </MudGrid>
</MudContainer>

@code {
    private List<ConversationDto> _escalatedConversations = new();
    private List<AgentDto> _availableAgents = new();
    private bool _loading = true;
    private bool _processing = false;
    private bool _autoAssign = false;
    private DateTime _lastUpdate = DateTime.Now;
    private Timer? _refreshTimer;
    
    // SignalR connection management
    private HubConnection? _hubConnection;
    private bool _isConnected = false;
    private bool _isConnecting = false;
    private string _connectionStatus = "Disconnected";

    protected override async Task OnInitializedAsync()
    {
        await RefreshData();
        await InitializeSignalRConnection();
        await InitializeBrowserNotifications();
    }

    private async Task RefreshData()
    {
        _loading = true;
        StateHasChanged();

        try
        {
            var escalatedTask = Mediator.Send(new GetEscalatedConversationsQuery());
            var agentsTask = Mediator.Send(new GetAvailableAgentsQuery());

            await Task.WhenAll(escalatedTask, agentsTask);

            var escalatedResult = await escalatedTask;
            var agentsResult = await agentsTask;

            if (escalatedResult.Succeeded)
                _escalatedConversations = escalatedResult.Data;
            
            if (agentsResult.Succeeded)
                _availableAgents = agentsResult.Data;

            _lastUpdate = DateTime.Now;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing data: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private async Task AcceptConversation(ConversationDto conversation)
    {
        _processing = true;
        try
        {
            var result = await Mediator.Send(new AssignAgentCommand(conversation.Id, "current-user-id")); // TODO: Get current user ID
            
            if (result.Succeeded)
            {
                Snackbar.Add($"Conversation accepted successfully", Severity.Success);
                await RefreshData();
            }
            else
            {
                Snackbar.Add($"Failed to accept conversation: {result.ErrorMessage}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error accepting conversation: {ex.Message}", Severity.Error);
        }
        finally
        {
            _processing = false;
        }
    }

    private async Task CompleteConversation(ConversationDto conversation)
    {
        _processing = true;
        try
        {
            var result = await Mediator.Send(new CompleteConversationCommand(conversation.Id, "Conversation completed by agent"));
            
            if (result.Succeeded)
            {
                Snackbar.Add($"Conversation completed successfully", Severity.Success);
                await RefreshData();
            }
            else
            {
                Snackbar.Add($"Failed to complete conversation: {result.ErrorMessage}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error completing conversation: {ex.Message}", Severity.Error);
        }
        finally
        {
            _processing = false;
        }
    }

    private async Task OpenConversation(ConversationDto conversation)
    {
        // TODO: Implement conversation detail view
        await JS.InvokeVoidAsync("open", $"/conversations/{conversation.Id}", "_blank");
    }

    // SignalR Connection Management
    private async Task InitializeSignalRConnection()
    {
        if (_isConnecting) return;
        
        _isConnecting = true;
        _connectionStatus = "Connecting...";
        StateHasChanged();
        
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(Navigation.ToAbsoluteUri(ISignalRHub.Url))
                .WithAutomaticReconnect()
                .Build();
            
            // Setup event handlers for real-time notifications
            _hubConnection.On<int, string, string, int, DateTime>("EscalationNotification", OnEscalationNotification);
            _hubConnection.On<int, int, int, bool>("AgentWorkloadUpdated", OnAgentWorkloadUpdated);
            _hubConnection.On<int>("EscalationQueueUpdated", OnEscalationQueueUpdated);
            _hubConnection.On<int, string, bool, string>("AgentAvailabilityChanged", OnAgentAvailabilityChanged);
            _hubConnection.On<int, string, string>("ConversationAssigned", OnConversationAssigned);
            _hubConnection.On<int, string>("ConversationCompleted", OnConversationCompleted);
            
            // Handle connection state changes
            _hubConnection.Reconnecting += (error) =>
            {
                InvokeAsync(() =>
                {
                    _connectionStatus = "Reconnecting...";
                    _isConnected = false;
                    StateHasChanged();
                });
                return Task.CompletedTask;
            };
            
            _hubConnection.Reconnected += (connectionId) =>
            {
                InvokeAsync(async () =>
                {
                    _connectionStatus = "Connected";
                    _isConnected = true;
                    StateHasChanged();
                    
                    // Rejoin the agent group after reconnection
                    await _hubConnection.InvokeAsync("JoinAgentGroup");
                });
                return Task.CompletedTask;
            };
            
            _hubConnection.Closed += (error) =>
            {
                InvokeAsync(() =>
                {
                    _connectionStatus = error == null ? "Disconnected" : $"Error: {error.Message}";
                    _isConnected = false;
                    StateHasChanged();
                });
                return Task.CompletedTask;
            };
            
            // Start the connection
            await _hubConnection.StartAsync();
            
            // Join the agent group to receive notifications
            await _hubConnection.InvokeAsync("JoinAgentGroup");
            
            _isConnected = true;
            _connectionStatus = "Connected";
            
            // Stop the timer-based refresh since we now have real-time updates
            _refreshTimer?.Dispose();
            _refreshTimer = null;
        }
        catch (Exception ex)
        {
            _connectionStatus = $"Failed: {ex.Message}";
            Snackbar.Add($"Failed to connect to real-time updates: {ex.Message}", Severity.Warning);
        }
        finally
        {
            _isConnecting = false;
            StateHasChanged();
        }
    }

    // Browser Notification Initialization
    private async Task InitializeBrowserNotifications()
    {
        try
        {
            // Check if browser supports notifications
            var isSupported = await JS.InvokeAsync<bool>("agentNotifications.isNotificationSupported");
            if (!isSupported) return;

            // Check current permission status
            var permission = await JS.InvokeAsync<string>("agentNotifications.getNotificationPermission");
            
            if (permission == "default")
            {
                // Request permission
                var newPermission = await JS.InvokeAsync<string>("agentNotifications.requestNotificationPermission");
                if (newPermission == "granted")
                {
                    Snackbar.Add("Browser notifications enabled for escalations", Severity.Success);
                }
            }
            
            // Initialize audio notifications
            await JS.InvokeVoidAsync("agentNotifications.initializeDefaultSounds");
        }
        catch (Exception ex)
        {
            // Notifications are optional, so just log the error
            Console.WriteLine($"Failed to initialize browser notifications: {ex.Message}");
        }
    }

    // SignalR Event Handlers
    private async Task OnEscalationNotification(int conversationId, string reason, string customerPhoneNumber, int priority, DateTime escalatedAt)
    {
        await InvokeAsync(async () =>
        {
            // Refresh the escalated conversations list to show the new escalation
            await RefreshEscalatedConversations();
            
            // Show in-app notification
            Snackbar.Add($"New escalation from {customerPhoneNumber}: {reason}", priority > 1 ? Severity.Error : Severity.Warning);
            
            // Show browser and audio notifications if user is not actively viewing the page
            try
            {
                var isVisible = await JS.InvokeAsync<bool>("document.hasFocus");
                if (!isVisible)
                {
                    // Create preference object (for now using defaults, will be configurable later)
                    var preferences = new 
                    { 
                        browserNotifications = true, 
                        audioNotifications = true, 
                        audioVolume = 0.7 
                    };
                    
                    await JS.InvokeVoidAsync("agentNotifications.showEscalationNotification", 
                        customerPhoneNumber, reason, priority, preferences);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error showing browser notification: {ex.Message}");
            }
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    private async Task OnAgentWorkloadUpdated(int agentId, int activeCount, int maxCount, bool isAvailable)
    {
        await InvokeAsync(async () =>
        {
            // Update the specific agent's workload in our list
            var agent = _availableAgents.FirstOrDefault(a => a.Id == agentId);
            if (agent != null)
            {
                agent.ActiveConversationCount = activeCount;
                agent.MaxConcurrentConversations = maxCount;
                // IsAvailable is a computed property, so we don't need to set it directly
            }
            else
            {
                // Refresh the full agent list if we don't have this agent
                await RefreshAvailableAgents();
            }
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    private async Task OnEscalationQueueUpdated(int queueCount)
    {
        await InvokeAsync(async () =>
        {
            // Refresh the escalated conversations to get the latest queue state
            await RefreshEscalatedConversations();
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    private async Task OnAgentAvailabilityChanged(int agentId, string status, bool isAvailable, string agentName)
    {
        await InvokeAsync(async () =>
        {
            // Update or refresh agent availability
            var agent = _availableAgents.FirstOrDefault(a => a.Id == agentId);
            if (agent != null)
            {
                // Update the underlying Status property, which affects IsAvailable and StatusText
                if (Enum.TryParse<CleanArchitecture.Blazor.Domain.Enums.AgentStatus>(status, out var agentStatus))
                {
                    agent.Status = agentStatus;
                }
            }
            else
            {
                await RefreshAvailableAgents();
            }
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    private async Task OnConversationAssigned(int conversationId, string agentId, string agentName)
    {
        await InvokeAsync(async () =>
        {
            // Remove from escalated list or refresh to get current state
            await RefreshEscalatedConversations();
            await RefreshAvailableAgents();
            
            Snackbar.Add($"Conversation assigned to {agentName}", Severity.Success);
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    private async Task OnConversationCompleted(int conversationId, string agentId)
    {
        await InvokeAsync(async () =>
        {
            // Refresh both lists to reflect the completion
            await RefreshEscalatedConversations();
            await RefreshAvailableAgents();
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    // Helper methods for targeted refreshes
    private async Task RefreshEscalatedConversations()
    {
        try
        {
            var result = await Mediator.Send(new GetEscalatedConversationsQuery());
            if (result.Succeeded)
                _escalatedConversations = result.Data;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing escalated conversations: {ex.Message}", Severity.Error);
        }
    }

    private async Task RefreshAvailableAgents()
    {
        try
        {
            var result = await Mediator.Send(new GetAvailableAgentsQuery());
            if (result.Succeeded)
                _availableAgents = result.Data;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing available agents: {ex.Message}", Severity.Error);
        }
    }

    private Color GetStatusColor(CleanArchitecture.Blazor.Domain.Enums.AgentStatus status)
    {
        return status switch
        {
            CleanArchitecture.Blazor.Domain.Enums.AgentStatus.Available => Color.Success,
            CleanArchitecture.Blazor.Domain.Enums.AgentStatus.Busy => Color.Warning,
            CleanArchitecture.Blazor.Domain.Enums.AgentStatus.Break => Color.Info,
            CleanArchitecture.Blazor.Domain.Enums.AgentStatus.Training => Color.Secondary,
            CleanArchitecture.Blazor.Domain.Enums.AgentStatus.Offline => Color.Error,
            _ => Color.Default
        };
    }

    private Color GetModeColor(CleanArchitecture.Blazor.Domain.Enums.ConversationMode mode)
    {
        return mode switch
        {
            CleanArchitecture.Blazor.Domain.Enums.ConversationMode.Escalating => Color.Warning,
            CleanArchitecture.Blazor.Domain.Enums.ConversationMode.Human => Color.Info,
            CleanArchitecture.Blazor.Domain.Enums.ConversationMode.HandingBackToBot => Color.Secondary,
            _ => Color.Default
        };
    }

    private Color GetWorkloadColor(double percentage)
    {
        return percentage switch
        {
            <= 50 => Color.Success,
            <= 80 => Color.Warning,
            _ => Color.Error
        };
    }

    private string FormatDuration(TimeSpan duration)
    {
        if (duration.TotalHours >= 1)
            return $"{(int)duration.TotalHours}h {duration.Minutes}m";
        else
            return $"{duration.Minutes}m {duration.Seconds}s";
    }

    private string GetConnectionIcon()
    {
        return _connectionStatus switch
        {
            "Connected" => Icons.Material.Filled.CloudDone,
            "Connecting..." => Icons.Material.Filled.CloudSync,
            "Reconnecting..." => Icons.Material.Filled.CloudSync,
            _ => Icons.Material.Filled.CloudOff
        };
    }

    private Color GetConnectionColor()
    {
        return _connectionStatus switch
        {
            "Connected" => Color.Success,
            "Connecting..." => Color.Info,
            "Reconnecting..." => Color.Warning,
            _ => Color.Error
        };
    }

    // Priority styling methods
    private string GetPriorityCardClass(int priority)
    {
        return priority switch
        {
            3 => "border-error", // Critical
            2 => "border-warning", // High
            _ => "" // Standard
        };
    }

    private Color GetPriorityColor(int priority)
    {
        return priority switch
        {
            3 => Color.Error, // Critical
            2 => Color.Warning, // High  
            _ => Color.Primary // Standard
        };
    }

    private string GetPriorityIcon(int priority)
    {
        return priority switch
        {
            3 => Icons.Material.Filled.PriorityHigh, // Critical
            2 => Icons.Material.Filled.Warning, // High
            _ => Icons.Material.Filled.Info // Standard
        };
    }

    public async ValueTask DisposeAsync()
    {
        _refreshTimer?.Dispose();
        
        if (_hubConnection is not null)
        {
            try
            {
                await _hubConnection.InvokeAsync("LeaveAgentGroup");
                await _hubConnection.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }
}