@page "/agent-dashboard"
@using CleanArchitecture.Blazor.Application.Features.Conversations.DTOs
@using CleanArchitecture.Blazor.Application.Features.Conversations.Queries.GetEscalatedConversations
@using CleanArchitecture.Blazor.Application.Features.Conversations.Queries.GetAvailableAgents
@using CleanArchitecture.Blazor.Application.Features.Conversations.Commands.AssignAgent
@using CleanArchitecture.Blazor.Application.Features.Conversations.Commands.CompleteConversation
@using CleanArchitecture.Blazor.Application.Common.Security
@using CleanArchitecture.Blazor.Domain.Enums
@using Microsoft.AspNetCore.SignalR.Client
@using CleanArchitecture.Blazor.Server.UI.Hubs
@using Microsoft.Extensions.Logging
@using CleanArchitecture.Blazor.Server.UI.Components.Agent
@using CleanArchitecture.Blazor.Application.Features.Agents.DTOs
@using CleanArchitecture.Blazor.Application.Features.Agents.Queries.GetPreferences
@using CleanArchitecture.Blazor.Application.Common.Interfaces.Identity
@using CleanArchitecture.Blazor.Server.UI.Services.SignalR

@attribute [Authorize(Policy = Permissions.Conversations.ViewAgentDashboard)]

@inject IMediator Mediator
@inject ISnackbar Snackbar
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject IUserContextAccessor CurrentUser
@inject SignalRConnectionService SignalRConnectionService
@inject IPermissionService PermissionService
@inject IJSRuntime JSRuntime
@inject IAutoAssignmentService AutoAssignmentService
@implements IAsyncDisposable

<script src="~/js/notifications.js"></script>

<PageTitle>Agent Dashboard</PageTitle>

<MudContainer MaxWidth="MaxWidth.False" Class="pa-6">
    <div class="d-flex justify-space-between align-center mb-6">
        <div>
            <MudText Typo="Typo.h4" Class="mb-2">Agent Dashboard</MudText>
            <MudText Typo="Typo.body1" Class="mud-text-secondary">Real-time conversation escalation management</MudText>
        </div>
        <div class="d-flex align-center gap-4">
            <MudChip T="string" 
                    Icon="@GetConnectionIcon()" 
                    Color="@GetConnectionColor()" 
                    Size="Size.Small">
                @_connectionStatus
            </MudChip>
            <MudChip T="string" Icon="Icons.Material.Filled.AccessTime" Color="Color.Info" Size="Size.Small">
                Last Updated: @_lastUpdate.ToString("HH:mm:ss")
            </MudChip>
            <MudButton Variant="Variant.Outlined" 
                      StartIcon="Icons.Material.Filled.Refresh" 
                      OnClick="RefreshData" 
                      Size="Size.Small"
                      Disabled="@(_connectionStatus == "Connecting..." || _connectionStatus == "Reconnecting...")">
                Refresh
            </MudButton>
        </div>
    </div>

    <MudGrid>
        <!-- Agent Status Panel -->
        <MudItem xs="12" md="4">
            <MudPaper Class="pa-4" Style="height: 600px; overflow-y: auto;">
                <div class="d-flex align-center mb-4">
                    <MudIcon Icon="Icons.Material.Filled.Support" Class="mr-2"/>
                    <MudText Typo="Typo.h6">Available Agents (@_availableAgents.Count)</MudText>
                </div>
                
                @if (_loading)
                {
                    <MudProgressCircular Indeterminate="true" Class="ma-4"/>
                }
                else
                {
                    @foreach (var agent in _availableAgents.OrderByDescending(a => a.IsAvailable))
                    {
                        <MudCard Class="@($"mb-2 {(agent.IsAvailable ? "border-success" : "border-warning")}")">
                            <MudCardContent Class="pa-3">
                                <div class="d-flex justify-space-between align-center">
                                    <div>
                                        <MudText Typo="Typo.subtitle2" Class="mb-1">
                                            @(agent.DisplayName ?? agent.UserName)
                                        </MudText>
                                        <div class="d-flex align-center gap-2">
                                            <MudChip T="string" Size="Size.Small" Color="@GetStatusColor(agent.Status)">
                                                @agent.StatusText
                                            </MudChip>
                                            <MudText Typo="Typo.caption">
                                                @agent.ActiveConversationCount/@agent.MaxConcurrentConversations
                                            </MudText>
                                        </div>
                                    </div>
                                    <MudProgressCircular Value="@agent.WorkloadPercentage" 
                                                       Color="@GetWorkloadColor(agent.WorkloadPercentage)"
                                                       Size="Size.Small"/>
                                </div>
                            </MudCardContent>
                        </MudCard>
                    }
                }
            </MudPaper>
        </MudItem>

        <!-- Escalated Conversations -->
        <MudItem xs="12" md="8">
            <MudPaper Class="pa-4" Style="height: 600px;">
                <div class="d-flex align-center justify-space-between mb-4">
                    <div class="d-flex align-center">
                        <MudIcon Icon="Icons.Material.Filled.PriorityHigh" Class="mr-2 mud-error-text"/>
                        <MudText Typo="Typo.h6">Escalated Conversations (@_escalatedConversations.Count)</MudText>
                    </div>
                    <MudSwitch T="bool" Checked="_autoAssign" 
                              CheckedChanged="OnAutoAssignToggle"
                              Label="Auto-assign" 
                              Color="Color.Primary"
                              Size="Size.Small"/>
                </div>

                @if (_loading)
                {
                    <div class="d-flex justify-center pa-8">
                        <MudProgressCircular Indeterminate="true" Size="Size.Large"/>
                    </div>
                }
                else if (!_escalatedConversations.Any())
                {
                    <div class="d-flex flex-column align-center justify-center pa-8">
                        <MudIcon Icon="Icons.Material.Outlined.CheckCircle" 
                                Style="font-size: 64px;" 
                                Class="mb-4 mud-success-text"/>
                        <MudText Typo="Typo.h6" Class="mb-2">All Clear!</MudText>
                        <MudText Typo="Typo.body2" Class="mud-text-secondary">
                            No escalated conversations at the moment.
                        </MudText>
                    </div>
                }
                else
                {
                    <div style="height: 500px; overflow-y: auto;">
                        @foreach (var conversation in _escalatedConversations)
                        {
                            <ConversationAssignmentCard @key="conversation.Id"
                                                       Conversation="conversation"
                                                       AvailableAgents="_availableAgents"
                                                       Processing="_processing"
                                                       OnConversationAssigned="OnConversationAssigned"
                                                       OnConversationAccepted="OnConversationAccepted"
                                                       OnConversationCompleted="OnConversationCompleted"
                                                       OnConversationViewed="OnConversationViewed" />
                        }
                    </div>
                }
            </MudPaper>
        </MudItem>
        
        <!-- Notification Preferences -->
        <MudItem xs="12">
            <NotificationPreferencesComponent />
        </MudItem>
    </MudGrid>
</MudContainer>

@code {
    private List<ConversationDto> _escalatedConversations = new();
    private List<CleanArchitecture.Blazor.Application.Features.Conversations.DTOs.AgentDto> _availableAgents = new();
    private bool _loading = true;
    private bool _processing = false;
    private bool _autoAssign = false;
    private DateTime _lastUpdate = DateTime.Now;
    private Timer? _refreshTimer;
    
    // SignalR connection management
    private HubConnection? _hubConnection;
    private string _connectionStatus = "Disconnected";
    
    // Notification preferences
    private AgentNotificationPreferencesDto? _notificationPreferences;

    protected override async Task OnInitializedAsync()
    {
        await LoadNotificationPreferences();
        await LoadAutoAssignmentSettings();
        await RefreshData();
        
        // Delay SignalR connection to ensure page is fully loaded and authenticated
        StateHasChanged();
        await Task.Delay(500);
        
        await InitializeSignalRConnection();
        await InitializeBrowserNotifications();
    }

    private async Task RefreshData()
    {
        _loading = true;
        StateHasChanged();

        try
        {
            var escalatedTask = Mediator.Send(new GetEscalatedConversationsQuery());
            var agentsTask = Mediator.Send(new GetAvailableAgentsQuery());

            await Task.WhenAll(escalatedTask, agentsTask);

            var escalatedResult = await escalatedTask;
            var agentsResult = await agentsTask;

            if (escalatedResult.Succeeded)
                _escalatedConversations = escalatedResult.Data;
            
            if (agentsResult.Succeeded)
            {
                _availableAgents = agentsResult.Data;
                Console.WriteLine($"AgentDashboard - Loaded {_availableAgents.Count} available agents");
            }
            else
            {
                Console.WriteLine($"AgentDashboard - Failed to load agents: {agentsResult.ErrorMessage}");
            }

            _lastUpdate = DateTime.Now;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing data: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    // Callback methods for ConversationAssignmentCard
    private async Task OnConversationAssigned(ConversationDto conversation)
    {
        await RefreshData();
    }

    private async Task OnConversationAccepted(ConversationDto conversation)
    {
        _processing = true;
        try
        {
            var currentUserId = CurrentUser.Current?.UserId ?? "";
            var result = await Mediator.Send(new AssignAgentCommand(conversation.ConversationReference, currentUserId));
            
            if (result.Succeeded)
            {
                Snackbar.Add($"Conversation accepted successfully", Severity.Success);
                await RefreshData();
            }
            else
            {
                Snackbar.Add($"Failed to accept conversation: {result.ErrorMessage}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error accepting conversation: {ex.Message}", Severity.Error);
        }
        finally
        {
            _processing = false;
        }
    }

    private async Task OnConversationCompleted(ConversationDto conversation)
    {
        _processing = true;
        try
        {
            var result = await Mediator.Send(new CompleteConversationCommand(conversation.ConversationReference, ResolutionCategory.Resolved, "Conversation completed by agent", true));
            
            if (result.Succeeded)
            {
                Snackbar.Add($"Conversation completed successfully", Severity.Success);
                await RefreshData();
            }
            else
            {
                Snackbar.Add($"Failed to complete conversation: {result.ErrorMessage}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error completing conversation: {ex.Message}", Severity.Error);
        }
        finally
        {
            _processing = false;
        }
    }

    private async Task OnConversationViewed(ConversationDto conversation)
    {
        await JS.InvokeVoidAsync("open", $"/conversations/{conversation.Id}", "_blank");
    }

    // SignalR Connection Management
    private async Task InitializeSignalRConnection()
    {
        _connectionStatus = "Connecting...";
        StateHasChanged();

        try
        {
            await SignalRConnectionService.EnsureConnectedAsync();
            _hubConnection = SignalRConnectionService.HubConnection;

            if (_hubConnection is null)
            {
                _connectionStatus = "Failed: Connection service did not provide a connection.";
                Snackbar.Add("Error connecting to real-time updates.", Severity.Error);
                StartPollingMode();
                return;
            }
            
            // Setup event handlers for real-time notifications
            _hubConnection.On<int, string, string, int, DateTime>("EscalationNotification", OnEscalationNotification);
            _hubConnection.On<int, string, string, int, DateTime>("TargetedEscalationNotification", OnTargetedEscalationNotification);
            _hubConnection.On<int, int, int, bool>("AgentWorkloadUpdated", OnAgentWorkloadUpdated);
            _hubConnection.On<int>("EscalationQueueUpdated", OnEscalationQueueUpdated);
            _hubConnection.On<int, string, bool, string>("AgentAvailabilityChanged", OnAgentAvailabilityChanged);
            _hubConnection.On<int, string, string>("ConversationAssigned", OnConversationAssigned);
            _hubConnection.On<int, string>("ConversationCompleted", OnConversationCompleted);
            
            // Handle connection state changes
            _hubConnection.Reconnecting += (error) =>
            {
                InvokeAsync(() =>
                {
                    _connectionStatus = "Reconnecting...";
                    StateHasChanged();
                });
                return Task.CompletedTask;
            };
            
            _hubConnection.Reconnected += (connectionId) =>
            {
                InvokeAsync(async () =>
                {
                    _connectionStatus = "Connected";
                    StateHasChanged();
                    
                    // Rejoin the agent group after reconnection
                    await _hubConnection.InvokeAsync("JoinAgentGroup");
                });
                return Task.CompletedTask;
            };
            
            _hubConnection.Closed += (error) =>
            {
                InvokeAsync(() =>
                {
                    _connectionStatus = error == null ? "Disconnected" : $"Error: {error.Message}";
                    StateHasChanged();
                });
                return Task.CompletedTask;
            };

            // Wait a moment for connection state to stabilize
            await Task.Delay(100);
            
            if (_hubConnection.State == HubConnectionState.Connected)
            {
                 // Join the agent group to receive notifications
                await _hubConnection.InvokeAsync("JoinAgentGroup");
                Console.WriteLine("SignalR: Joined agent group");
                _connectionStatus = "Connected";
                // Stop the timer-based refresh since we now have real-time updates
                _refreshTimer?.Dispose();
                _refreshTimer = null;
            }
            else
            {
                _connectionStatus = $"Failed: Connection state is {_hubConnection.State}";
                Console.WriteLine($"SignalR: Connection failed, state is {_hubConnection.State}");
                StartPollingMode();
            }
        }
        catch (Exception ex)
        {
            var errorMessage = ex.InnerException?.Message ?? ex.Message;
            _connectionStatus = $"Failed: {errorMessage}";
            Snackbar.Add($"Real-time updates unavailable: {errorMessage}. Using polling mode.", Severity.Info);
            StartPollingMode();
        }
        finally
        {
            StateHasChanged();
        }
    }

    // Browser Notification Initialization
    private async Task InitializeBrowserNotifications()
    {
        try
        {
            // Check if browser supports notifications
            var isSupported = await JS.InvokeAsync<bool>("agentNotifications.isNotificationSupported");
            if (!isSupported) return;

            // Check current permission status
            var permission = await JS.InvokeAsync<string>("agentNotifications.getNotificationPermission");
            
            if (permission == "default")
            {
                // Request permission
                var newPermission = await JS.InvokeAsync<string>("agentNotifications.requestNotificationPermission");
                if (newPermission == "granted")
                {
                    Snackbar.Add("Browser notifications enabled for escalations", Severity.Success);
                }
            }
            
            // Initialize audio notifications
            await JS.InvokeVoidAsync("agentNotifications.initializeDefaultSounds");
        }
        catch (Exception ex)
        {
            // Notifications are optional, so just log the error
            Console.WriteLine($"Failed to initialize browser notifications: {ex.Message}");
        }
    }

    // SignalR Event Handlers
    private async Task OnEscalationNotification(int conversationId, string reason, string customerPhoneNumber, int priority, DateTime escalatedAt)
    {
        await InvokeAsync(async () =>
        {
            // Refresh the escalated conversations list to show the new escalation
            await RefreshEscalatedConversations();
            
            // Show in-app notification
            Snackbar.Add($"New escalation from {customerPhoneNumber}: {reason}", priority > 1 ? Severity.Error : Severity.Warning);
            
            // Show browser and audio notifications if user is not actively viewing the page
            try
            {
                var isVisible = await JS.InvokeAsync<bool>("document.hasFocus");
                if (!isVisible)
                {
                    // Create preference object (for now using defaults, will be configurable later)
                    var preferences = new 
                    { 
                        browserNotifications = true, 
                        audioNotifications = true, 
                        audioVolume = 0.7 
                    };
                    
                    await JS.InvokeVoidAsync("agentNotifications.showEscalationNotification", 
                        customerPhoneNumber, reason, priority, preferences);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error showing browser notification: {ex.Message}");
            }
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    private async Task OnAgentWorkloadUpdated(int agentId, int activeCount, int maxCount, bool isAvailable)
    {
        await InvokeAsync(async () =>
        {
            // Update the specific agent's workload in our list
            var agent = _availableAgents.FirstOrDefault(a => a.Id == agentId);
            if (agent != null)
            {
                agent.ActiveConversationCount = activeCount;
                agent.MaxConcurrentConversations = maxCount;
                // IsAvailable is a computed property, so we don't need to set it directly
            }
            else
            {
                // Refresh the full agent list if we don't have this agent
                await RefreshAvailableAgents();
            }
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    private async Task OnEscalationQueueUpdated(int queueCount)
    {
        await InvokeAsync(async () =>
        {
            // Refresh the escalated conversations to get the latest queue state
            await RefreshEscalatedConversations();
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    private async Task OnAgentAvailabilityChanged(int agentId, string status, bool isAvailable, string agentName)
    {
        await InvokeAsync(async () =>
        {
            // Update or refresh agent availability
            var agent = _availableAgents.FirstOrDefault(a => a.Id == agentId);
            if (agent != null)
            {
                // Update the underlying Status property, which affects IsAvailable and StatusText
                if (Enum.TryParse<CleanArchitecture.Blazor.Domain.Enums.AgentStatus>(status, out var agentStatus))
                {
                    agent.Status = agentStatus;
                }
            }
            else
            {
                await RefreshAvailableAgents();
            }
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    private async Task OnConversationAssigned(int conversationId, string agentId, string agentName)
    {
        await InvokeAsync(async () =>
        {
            // Remove from escalated list or refresh to get current state
            await RefreshEscalatedConversations();
            await RefreshAvailableAgents();
            
            Snackbar.Add($"Conversation assigned to {agentName}", Severity.Success);
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    private async Task OnConversationCompleted(int conversationId, string agentId)
    {
        await InvokeAsync(async () =>
        {
            // Refresh both lists to reflect the completion
            await RefreshEscalatedConversations();
            await RefreshAvailableAgents();
            
            _lastUpdate = DateTime.Now;
            StateHasChanged();
        });
    }

    // Helper methods for targeted refreshes
    private async Task RefreshEscalatedConversations()
    {
        try
        {
            var result = await Mediator.Send(new GetEscalatedConversationsQuery());
            if (result.Succeeded)
                _escalatedConversations = result.Data;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing escalated conversations: {ex.Message}", Severity.Error);
        }
    }

    private async Task RefreshAvailableAgents()
    {
        try
        {
            var result = await Mediator.Send(new GetAvailableAgentsQuery());
            if (result.Succeeded)
                _availableAgents = result.Data;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error refreshing available agents: {ex.Message}", Severity.Error);
        }
    }

    private Color GetStatusColor(CleanArchitecture.Blazor.Domain.Enums.AgentStatus status)
    {
        return status switch
        {
            CleanArchitecture.Blazor.Domain.Enums.AgentStatus.Available => Color.Success,
            CleanArchitecture.Blazor.Domain.Enums.AgentStatus.Busy => Color.Warning,
            CleanArchitecture.Blazor.Domain.Enums.AgentStatus.Break => Color.Info,
            CleanArchitecture.Blazor.Domain.Enums.AgentStatus.Training => Color.Secondary,
            CleanArchitecture.Blazor.Domain.Enums.AgentStatus.Offline => Color.Error,
            _ => Color.Default
        };
    }

    private Color GetModeColor(CleanArchitecture.Blazor.Domain.Enums.ConversationMode mode)
    {
        return mode switch
        {
            CleanArchitecture.Blazor.Domain.Enums.ConversationMode.Escalating => Color.Warning,
            CleanArchitecture.Blazor.Domain.Enums.ConversationMode.Human => Color.Info,
            CleanArchitecture.Blazor.Domain.Enums.ConversationMode.HandingBackToBot => Color.Secondary,
            _ => Color.Default
        };
    }

    private Color GetWorkloadColor(double percentage)
    {
        return percentage switch
        {
            <= 50 => Color.Success,
            <= 80 => Color.Warning,
            _ => Color.Error
        };
    }

    private string FormatDuration(TimeSpan duration)
    {
        if (duration.TotalHours >= 1)
            return $"{(int)duration.TotalHours}h {duration.Minutes}m";
        else
            return $"{duration.Minutes}m {duration.Seconds}s";
    }

    private string GetConnectionIcon()
    {
        return _connectionStatus switch
        {
            "Connected" => Icons.Material.Filled.CloudDone,
            "Connecting..." => Icons.Material.Filled.CloudSync,
            "Reconnecting..." => Icons.Material.Filled.CloudSync,
            "Polling Mode" => Icons.Material.Filled.Refresh,
            _ => Icons.Material.Filled.CloudOff
        };
    }

    private Color GetConnectionColor()
    {
        return _connectionStatus switch
        {
            "Connected" => Color.Success,
            "Connecting..." => Color.Info,
            "Reconnecting..." => Color.Warning,
            "Polling Mode" => Color.Warning,
            _ => Color.Error
        };
    }


    private async Task LoadNotificationPreferences()
    {
        try
        {
            var query = new GetAgentPreferencesQuery
            {
                ApplicationUserId = CurrentUser.Current?.UserId ?? ""
            };
            
            var result = await Mediator.Send(query);
            if (result.Succeeded)
            {
                _notificationPreferences = result.Data;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load notification preferences: {ex.Message}");
            // Use defaults if preferences loading fails
            _notificationPreferences = new AgentNotificationPreferencesDto
            {
                ApplicationUserId = CurrentUser.Current?.UserId ?? "",
                TenantId = CurrentUser.Current?.TenantId ?? ""
            };
        }
    }

    private async Task LoadAutoAssignmentSettings()
    {
        try
        {
            var tenantId = CurrentUser.Current?.TenantId ?? "";
            var settings = await AutoAssignmentService.GetAutoAssignmentSettingsAsync(tenantId);
            _autoAssign = settings.IsEnabled;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load auto-assignment settings: {ex.Message}");
            _autoAssign = false; // Default to false if loading fails
        }
    }

    private async Task OnAutoAssignToggle(bool enabled)
    {
        try
        {
            var tenantId = CurrentUser.Current?.TenantId ?? "";
            var settings = await AutoAssignmentService.GetAutoAssignmentSettingsAsync(tenantId);
            
            settings.IsEnabled = enabled;
            settings.LastModifiedBy = CurrentUser.Current?.UserId ?? "";
            settings.LastModified = DateTime.UtcNow;
            
            var result = await AutoAssignmentService.UpdateAutoAssignmentSettingsAsync(tenantId, settings);
            
            if (result.Succeeded)
            {
                _autoAssign = enabled;
                Snackbar.Add($"Auto-assignment {(enabled ? "enabled" : "disabled")}", Severity.Success);
            }
            else
            {
                // Revert the toggle if update failed
                _autoAssign = !enabled;
                Snackbar.Add($"Failed to update auto-assignment setting: {result.ErrorMessage}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            // Revert the toggle if update failed
            _autoAssign = !enabled;
            Snackbar.Add($"Error updating auto-assignment setting: {ex.Message}", Severity.Error);
        }
        
        StateHasChanged();
    }

    private async Task OnTargetedEscalationNotification(int conversationId, string reason, string customerPhoneNumber, int priority, DateTime escalatedAt)
    {
        await InvokeAsync(async () =>
        {
            // This is a targeted notification based on user preferences
            if (_notificationPreferences == null) return;
            
            // Check if user wants notifications for this priority level
            bool shouldNotify = _notificationPreferences.ShouldNotifyForPriority(priority);
            if (!shouldNotify) return;
            
            try
            {
                // Create preference object based on user settings
                var preferences = new 
                { 
                    browserNotifications = _notificationPreferences.EnableBrowserNotifications, 
                    audioNotifications = _notificationPreferences.EnableAudioAlerts, 
                    audioVolume = _notificationPreferences.AudioVolume / 100.0 // Convert to 0-1 range
                };
                
                await JS.InvokeVoidAsync("agentNotifications.showEscalationNotification", 
                    customerPhoneNumber, reason, priority, preferences);
                
                // Also show in-app notification if browser doesn't have focus
                var isVisible = await JS.InvokeAsync<bool>("document.hasFocus");
                if (!isVisible)
                {
                    var severityLevel = priority > 2 ? Severity.Error : priority > 1 ? Severity.Warning : Severity.Info;
                    Snackbar.Add($"Priority {priority} escalation from {customerPhoneNumber}: {reason}", severityLevel);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error showing targeted notification: {ex.Message}");
            }
        });
    }

    private void StartPollingMode()
    {
        _connectionStatus = "Polling Mode";
        
        // Start a timer to refresh data periodically as fallback
        _refreshTimer = new Timer(async _ =>
        {
            try
            {
                await InvokeAsync(async () =>
                {
                    await RefreshData();
                    StateHasChanged();
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Polling refresh error: {ex.Message}");
            }
        }, null, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30)); // Refresh every 30 seconds
    }

    public async ValueTask DisposeAsync()
    {
        _refreshTimer?.Dispose();
        
        if (_hubConnection is not null)
        {
            try
            {
                await _hubConnection.InvokeAsync("LeaveAgentGroup");
                await _hubConnection.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }
}