@page "/agent/conversations/{ConversationId}"
@using CleanArchitecture.Blazor.Application.Features.Conversations.DTOs
@using CleanArchitecture.Blazor.Application.Common.Models
@using CleanArchitecture.Blazor.Domain.Enums
@using CleanArchitecture.Blazor.Application.Common.Security
@using CleanArchitecture.Blazor.Application.Features.Conversations.Queries.GetConversationById
@using CleanArchitecture.Blazor.Server.UI.Components.Conversations
@using CleanArchitecture.Blazor.Server.UI.Components.Common
@using CleanArchitecture.Blazor.Server.UI.Services.SignalR
@using Microsoft.AspNetCore.SignalR.Client
@using System.Timers
@* @attribute [Authorize(Policy = Permissions.Conversations.View)] *@
@inject IMediator Mediator
@inject IStringLocalizer<SharedResource> L
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject SignalRConnectionService SignalRService
@inject IDialogService DialogService
@implements IAsyncDisposable

<PageTitle>@L["Conversation Details"] - @(conversationDetails?.Conversation.ConversationReference ?? ConversationId)</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="relative">
    @if (loading)
    {
        <div class="d-flex justify-center align-center" style="height: 400px;">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
        </div>
    }
    else if (conversationDetails == null)
    {
        <div class="d-flex flex-column align-center justify-center" style="height: 400px;">
            <MudIcon Icon="@Icons.Material.Filled.ErrorOutline" Style="font-size: 4rem; opacity: 0.3;" />
            <MudText Typo="Typo.h6" Color="Color.Secondary" Class="mt-4">
                @L["Conversation not found"]
            </MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mt-2">
                @L["The conversation with ID"] @ConversationId @L["could not be found. It may have been deleted or you may not have permission to view it."]
            </MudText>
            <div class="d-flex gap-2 mt-4">
                <MudButton Color="Color.Primary" Variant="Variant.Outlined" OnClick="@(() => Navigation.NavigateTo("/agent/conversations"))">
                    @L["Back to Conversations"]
                </MudButton>
                <MudButton Color="Color.Secondary" Variant="Variant.Text" OnClick="@LoadConversation">
                    @L["Retry"]
                </MudButton>
            </div>
        </div>
    }
    else
    {
        <div class="d-flex flex-column gap-4">
            <!-- Header -->
            <div class="d-flex align-center justify-space-between">
                <div class="d-flex align-center gap-4">
                    <MudIconButton Icon="@Icons.Material.Filled.ArrowBack" 
                                  OnClick="@(() => Navigation.NavigateTo("/agent/conversations"))"
                                  Size="Size.Medium"
                                  Variant="Variant.Outlined" />
                    <div>
                        <MudText Typo="Typo.h5">@L["Conversation"] @conversationDetails.Conversation.ConversationReference</MudText>
                        <MudText Typo="Typo.body2" Color="Color.Secondary">
                            @L["Started"] @conversationDetails.Conversation.Created.ToString("MMM dd, yyyy HH:mm") • 
                            @L["Last activity"] @conversationDetails.Conversation.LastActivityAt.ToString("MMM dd, yyyy HH:mm")
                        </MudText>
                    </div>
                </div>
                
                <div class="d-flex align-center gap-2">
                    <MudChip T="string" Size="Size.Medium" 
                            Color="@GetStatusColor(conversationDetails.Conversation.Status)"
                            Variant="Variant.Filled">
                        @conversationDetails.Conversation.Status
                    </MudChip>
                    <MudChip T="string" Size="Size.Medium" Color="Color.Info" Variant="Variant.Outlined">
                        @conversationDetails.Conversation.Mode
                    </MudChip>
                    <!-- Connection Status Indicator -->
                    <MudChip T="string" Size="Size.Small" 
                            Color="@_connectionColor" 
                            Variant="Variant.Text"
                            Icon="@_connectionIcon"
                            Class="connection-status">
                        @_connectionStatus
                    </MudChip>
                    <MudMenu Icon="@Icons.Material.Filled.MoreVert" 
                            AnchorOrigin="Origin.BottomRight" 
                            TransformOrigin="Origin.TopRight">
                        <MudMenuItem Icon="@Icons.Material.Filled.Download">@L["Export"]</MudMenuItem>
                        <MudMenuItem Icon="@Icons.Material.Filled.Share">@L["Share"]</MudMenuItem>
                        <MudMenuItem Icon="@Icons.Material.Filled.CheckCircle" 
                                    OnClick="OpenWrapupDialog"
                                    Disabled="@(conversationDetails?.Conversation.Status == ConversationStatus.Completed)">
                            @L["Complete Conversation"]
                        </MudMenuItem>
                        <MudMenuItem Icon="@Icons.Material.Filled.Archive">@L["Archive"]</MudMenuItem>
                    </MudMenu>
                </div>
            </div>

            <MudGrid>
                <!-- Left Column - Conversation Info -->
                <MudItem xs="12" md="4">
                    <MudCard>
                        <MudCardHeader>
                            <CardHeaderContent>
                                <MudText Typo="Typo.h6">@L["Conversation Info"]</MudText>
                            </CardHeaderContent>
                        </MudCardHeader>
                        <MudCardContent>
                            <div class="d-flex flex-column gap-3">
                                <!-- User Info -->
                                <div>
                                    <MudText Typo="Typo.subtitle2" Color="Color.Primary">@L["User"]</MudText>
                                    <MudText Typo="Typo.body2">
                                        @(conversationDetails.Conversation.UserName ?? conversationDetails.Conversation.UserId ?? L["Unknown"])
                                    </MudText>
                                    @if (!string.IsNullOrEmpty(conversationDetails.Conversation.WhatsAppPhoneNumber))
                                    {
                                        <MudText Typo="Typo.caption" Color="Color.Secondary">
                                            @conversationDetails.Conversation.WhatsAppPhoneNumber
                                        </MudText>
                                    }
                                </div>

                                <!-- Agent Info -->
                                @if (!string.IsNullOrEmpty(conversationDetails.Conversation.CurrentAgentName))
                                {
                                    <div>
                                        <MudText Typo="Typo.subtitle2" Color="Color.Primary">@L["Current Agent"]</MudText>
                                        <MudText Typo="Typo.body2">
                                            @conversationDetails.Conversation.CurrentAgentName
                                        </MudText>
                                    </div>
                                }

                                <!-- Duration -->
                                <div>
                                    <MudText Typo="Typo.subtitle2" Color="Color.Primary">@L["Duration"]</MudText>
                                    <MudText Typo="Typo.body2">
                                        @conversationDetails.Conversation.DurationText
                                    </MudText>
                                </div>

                                <!-- Message Count -->
                                <div>
                                    <MudText Typo="Typo.subtitle2" Color="Color.Primary">@L["Messages"]</MudText>
                                    <MudText Typo="Typo.body2">
                                        @conversationDetails.Conversation.MessageCount
                                    </MudText>
                                </div>

                                <!-- Last Activity -->
                                <div>
                                    <MudText Typo="Typo.subtitle2" Color="Color.Primary">@L["Last Activity"]</MudText>
                                    <MudText Typo="Typo.body2">
                                        @conversationDetails.Conversation.LastActivityAt.ToString("MMM dd, yyyy HH:mm")
                                    </MudText>
                                </div>

                                <!-- Summary -->
                                @if (!string.IsNullOrEmpty(conversationDetails.Conversation.ConversationSummary))
                                {
                                    <div>
                                        <MudText Typo="Typo.subtitle2" Color="Color.Primary">@L["Summary"]</MudText>
                                        <MudText Typo="Typo.body2">
                                            @conversationDetails.Conversation.ConversationSummary
                                        </MudText>
                                    </div>
                                }
                                
                                <!-- Agent Transfer Controls -->
                                <AgentTransferDropdown Conversation="@conversationDetails.Conversation" 
                                                      OnTransferCompleted="HandleTransferCompleted" />
                            </div>
                        </MudCardContent>
                    </MudCard>

                    <!-- Participants -->
                    @if (conversationDetails.Participants?.Any() == true)
                    {
                        <MudCard Class="mt-4">
                            <MudCardHeader>
                                <CardHeaderContent>
                                    <MudText Typo="Typo.h6">@L["Participants"]</MudText>
                                </CardHeaderContent>
                            </MudCardHeader>
                            <MudCardContent>
                                @foreach (var participant in conversationDetails.Participants)
                                {
                                    <div class="d-flex align-center justify-space-between mb-2">
                                        <div>
                                            <MudText Typo="Typo.body2">
                                                @participant.ParticipantName
                                            </MudText>
                                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                                @participant.Type
                                            </MudText>
                                        </div>
                                        <MudChip T="string" Size="Size.Small" 
                                                Color="@(participant.IsActive ? Color.Success : Color.Secondary)">
                                            @(participant.IsActive ? L["Active"] : L["Left"])
                                        </MudChip>
                                    </div>
                                }
                            </MudCardContent>
                        </MudCard>
                    }

                    <!-- AI Insights -->
                    <ConversationInsightsComponent ConversationId="@(conversationDetails?.Conversation.Id ?? 0)" />
                </MudItem>

                <!-- Right Column - Messages -->
                <MudItem xs="12" md="8">
                    <MudCard Style="height: 700px; display: flex; flex-direction: column; position: relative;">
                        <!-- Agent Presence Indicator -->
                        <AgentPresenceIndicator ConversationId="@ConversationId" CurrentViewers="@_conversationViewers" />
                        
                        <MudCardHeader Class="pb-2">
                            <CardHeaderContent>
                                <div class="d-flex align-center justify-space-between">
                                    <MudText Typo="Typo.h6">@L["Conversation Messages"]</MudText>
                                    <MudChip T="string" Size="Size.Small" Color="Color.Primary" Variant="Variant.Text">
                                        @(conversationDetails.Messages?.Count ?? 0) @L["messages"]
                                    </MudChip>
                                </div>
                            </CardHeaderContent>
                        </MudCardHeader>
                        <ConversationMessagesComponent ConversationDetails="@conversationDetails" 
                                                       CustomerTyping="@_customerTyping" />
                        
                        <ConversationInteractionComponent ConversationDetails="@conversationDetails"
                                                          OnMessageSent="HandleNewMessage"
                                                          SendingMessage="@_sendingMessage" />
                    </MudCard>
                </MudItem>
            </MudGrid>

            <!-- Handoff History -->
            @if (conversationDetails.HandoffHistory?.Any() == true)
            {
                <MudCard>
                    <MudCardHeader>
                        <CardHeaderContent>
                            <MudText Typo="Typo.h6">@L["Handoff History"]</MudText>
                        </CardHeaderContent>
                    </MudCardHeader>
                    <MudCardContent>
                        <MudTimeline TimelineOrientation="TimelineOrientation.Vertical" TimelinePosition="TimelinePosition.Start">
                            @foreach (var handoff in conversationDetails.HandoffHistory.OrderByDescending(h => h.InitiatedAt))
                            {
                                <MudTimelineItem Color="@GetHandoffColor(handoff.Status)" Variant="Variant.Filled" Size="Size.Small">
                                    <ItemOpposite>
                                        <MudText Typo="Typo.caption" Color="Color.Secondary">
                                            @handoff.InitiatedAt.ToString("MMM dd, yyyy HH:mm")
                                        </MudText>
                                    </ItemOpposite>
                                    <ItemContent>
                                        <MudCard Elevation="1">
                                            <MudCardContent Class="py-2">
                                                <div class="d-flex align-center justify-space-between mb-1">
                                                    <MudText Typo="Typo.subtitle2">
                                                        @handoff.HandoffType handoff
                                                    </MudText>
                                                    <MudChip T="string" Size="Size.Small" Color="@GetHandoffColor(handoff.Status)">
                                                        @handoff.Status
                                                    </MudChip>
                                                </div>
                                                <MudText Typo="Typo.body2" Class="mb-1">
                                                    @L["From"]: @handoff.FromParticipantType → @L["To"]: @handoff.ToParticipantType
                                                </MudText>
                                                <MudText Typo="Typo.body2" Color="Color.Secondary">
                                                    @handoff.Reason
                                                </MudText>
                                                @if (!string.IsNullOrEmpty(handoff.Notes))
                                                {
                                                    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mt-1">
                                                        @L["Notes"]: @handoff.Notes
                                                    </MudText>
                                                }
                                            </MudCardContent>
                                        </MudCard>
                                    </ItemContent>
                                </MudTimelineItem>
                            }
                        </MudTimeline>
                    </MudCardContent>
                </MudCard>
            }
        </div>
    }
</MudContainer>

<style>
    .message-container {
        scroll-behavior: smooth;
    }
    
    .message-container::-webkit-scrollbar {
        width: 6px;
    }
    
    .message-container::-webkit-scrollbar-track {
        background: var(--mud-palette-surface-variant);
        border-radius: 3px;
    }
    
    .message-container::-webkit-scrollbar-thumb {
        background: var(--mud-palette-text-secondary);
        border-radius: 3px;
    }
    
    .message-container::-webkit-scrollbar-thumb:hover {
        background: var(--mud-palette-text-primary);
    }
    
    .message-bubble {
        border-radius: 18px;
        padding: 12px 16px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease-in-out;
    }
    
    .message-bubble:hover {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }
    
    .user-message {
        border-bottom-right-radius: 4px;
    }
    
    .assistant-message {
        border-bottom-left-radius: 4px;
    }
    
    .message-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
    }
    
    .message-content {
        margin-bottom: 4px;
    }
    
    .message-text {
        line-height: 1.5;
        word-wrap: break-word;
        white-space: pre-wrap;
    }
    
    .message-footer {
        margin-top: 8px;
        display: flex;
        justify-content: flex-start;
    }
    
    .user-message .message-header,
    .user-message .message-text {
        color: white;
    }
    
    .user-message .message-footer .mud-chip {
        background-color: rgba(255, 255, 255, 0.2);
        color: white;
    }
    
    /* Smooth animations for message loading */
    @@keyframes messageSlideIn {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .message-bubble {
        animation: messageSlideIn 0.3s ease-out;
    }
    
    /* Enhanced card styling */
    .mud-card {
        border-radius: 12px;
        border: 1px solid var(--mud-palette-lines-default);
    }
    
    .mud-card-header {
        border-bottom: 1px solid var(--mud-palette-lines-default);
    }
    
    /* Timeline styling for handoffs */
    .mud-timeline-item {
        margin-bottom: 16px;
    }
    
    .mud-timeline-item .mud-card {
        border-left: 3px solid var(--mud-palette-primary);
    }
</style>

@code {
    [Parameter] public string ConversationId { get; set; } = default!;
    
    private bool loading = true;
    private bool _sendingMessage = false;
    private ConversationDetailsDto? conversationDetails;
    private HubConnection? _hubConnection;
    
    // Real-time state
    private bool _customerTyping = false;
    private List<ConversationViewerDto> _conversationViewers = new();
    private string _connectionStatus = "Connecting...";
    private Color _connectionColor = Color.Warning;
    private string _connectionIcon = Icons.Material.Filled.Sync;
    private string _originalTitle = string.Empty;
    private int _unreadMessages = 0;
    private Timer? _typingTimer;
    // SignalR handler disposables to avoid calling Remove(method) which clears other components' handlers
    private IDisposable? _newMessageReceivedHandler;
    private IDisposable? _conversationStatusChangedHandler;
    private IDisposable? _customerTypingHandler;
    private IDisposable? _agentJoinedHandler;
    private IDisposable? _agentLeftHandler;
    private IDisposable? _conversationViewersUpdatedHandler;
    private IDisposable? _legacyConversationAssignedHandler;
    private IDisposable? _legacyConversationCompletedHandler;

    protected override async Task OnInitializedAsync()
    {
        _originalTitle = "Conversation Details";
        await LoadConversation();
        await InitializeSignalR();
        JoinConversationViewers();
    }
    
    protected override async Task OnParametersSetAsync()
    {
        if (_hubConnection?.State == HubConnectionState.Connected)
        {
            // Leave the old conversation group and join the new one
            await _hubConnection.InvokeAsync("LeaveConversationGroup", ConversationId);
            await _hubConnection.InvokeAsync("JoinConversationGroup", ConversationId);
        }
        
        // Reset notification count when switching conversations
        _unreadMessages = 0;
        await UpdateBrowserTitle();
    }

    private async Task LoadConversation()
    {
        loading = true;
        try
        {
            var query = new GetConversationByIdQuery(null,ConversationId);
            var result = await Mediator.Send(query);
            
            if (result.Succeeded)
            {
                conversationDetails = result.Data;
                Snackbar.Add(L["Conversation loaded successfully"], Severity.Success);
            }
            else
            {
                conversationDetails = null;
                var errorMessage = string.Join(", ", result.Errors ?? new[] { "Unknown error" });
                Snackbar.Add($"{L["Failed to load conversation"]}: {errorMessage}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading conversation: {ex.Message}");
            conversationDetails = null;
            Snackbar.Add($"{L["Error loading conversation"]}: {ex.Message}", Severity.Error);
        }
        finally
        {
            loading = false;
        }
    }

    private Color GetStatusColor(ConversationStatus status)
    {
        return status switch
        {
            ConversationStatus.Active => Color.Success,
            ConversationStatus.Completed => Color.Secondary,
            ConversationStatus.Abandoned => Color.Warning,
            ConversationStatus.Archived => Color.Info,
            _ => Color.Default
        };
    }

    private Color GetHandoffColor(HandoffStatus status)
    {
        return status switch
        {
            HandoffStatus.Initiated => Color.Warning,
            HandoffStatus.Accepted => Color.Info,
            HandoffStatus.Completed => Color.Success,
            HandoffStatus.Failed => Color.Error,
            HandoffStatus.Cancelled => Color.Secondary,
            _ => Color.Default
        };
    }

    private string GetMessageAlignment(string role)
    {
        return role == "user" ? "d-flex justify-start" : "d-flex justify-end";
    }

    private string GetMessageCardClass(string role)
    {
        return role == "user" ? "mud-theme-primary" : "mud-elevation-1";
    }

    private string GetMessageStyle(string role)
    {
        return role == "user" 
            ? "background-color: var(--mud-palette-primary); color: white;" 
            : "background-color: var(--mud-palette-surface);";
    }

    
    private async Task InitializeSignalR()
    {
        try
        {
            // Use the SignalRConnectionService to get the connection
            await SignalRService.EnsureConnectedAsync();
            _hubConnection = SignalRService.HubConnection;

            if (_hubConnection != null)
            {
                // Connection state handlers
                _hubConnection.Reconnecting += OnReconnecting;
                _hubConnection.Reconnected += OnReconnected;
                _hubConnection.Closed += OnConnectionClosed;

                // Subscribe to real-time message updates (store disposables so only this component unsubscribes its own handlers)
                _newMessageReceivedHandler = _hubConnection.On<ConversationMessageDto>("NewMessageReceived", OnNewMessageReceived);
                Console.WriteLine($"[ConversationDetail] Subscribed to NewMessageReceived events for conversation: {ConversationId}");

                // Subscribe to conversation status changes
                _conversationStatusChangedHandler = _hubConnection.On<string, ConversationStatus>("ConversationStatusChanged", OnConversationStatusChanged);

                // Subscribe to typing indicators
                _customerTypingHandler = _hubConnection.On<string, bool>("CustomerTyping", OnCustomerTyping);

                // Subscribe to agent presence updates
                _agentJoinedHandler = _hubConnection.On<string, string, string>("AgentJoinedConversation", OnAgentJoinedConversation);
                _agentLeftHandler = _hubConnection.On<string, string>("AgentLeftConversation", OnAgentLeftConversation);
                _conversationViewersUpdatedHandler = _hubConnection.On<string, List<ConversationViewerDto>>("ConversationViewersUpdated", OnConversationViewersUpdated);

                // Subscribe to conversation assignment and completion (legacy handlers for backward compatibility)
                _legacyConversationAssignedHandler = _hubConnection.On<int, string, string>("ConversationAssigned", OnConversationAssigned);
                _legacyConversationCompletedHandler = _hubConnection.On<int, string>("ConversationCompleted", OnConversationCompleted);

                UpdateConnectionStatus("connected");
                
                // Join conversation group for targeted updates
                Console.WriteLine($"[ConversationDetail] Joining conversation group: Conversation_{ConversationId}");
                await _hubConnection.InvokeAsync("JoinConversationGroup", ConversationId);
                Console.WriteLine($"[ConversationDetail] Successfully joined conversation group for: {ConversationId}");
            }
            else
            {
                UpdateConnectionStatus("error");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalR connection error: {ex.Message}");
            UpdateConnectionStatus("error");
        }
    }

    // Enhanced real-time event handlers
    private Task OnReconnecting(Exception? exception)
    {
        UpdateConnectionStatus("reconnecting");
        return Task.CompletedTask;
    }

    private Task OnReconnected(string? connectionId)
    {
        UpdateConnectionStatus("connected");
        return InvokeAsync(async () =>
        {
            await _hubConnection!.InvokeAsync("JoinConversationGroup", ConversationId);
            StateHasChanged();
        });
    }

    private Task OnConnectionClosed(Exception? exception)
    {
        UpdateConnectionStatus("disconnected");
        return Task.CompletedTask;
    }

    private async Task OnNewMessageReceived(ConversationMessageDto message)
    {
        Console.WriteLine($"[ConversationDetail] OnNewMessageReceived - MessageId: {message.Id}, ConversationId: {message.ConversationId}, BotFrameworkId: {message.BotFrameworkConversationId}, Content: {message.Content}, CurrentConversationId: {ConversationId}");
        
        // Test: Log that we received the SignalR event
        Console.WriteLine($"[ConversationDetail] 🔥 SignalR event received! Message: {message.Content}");
        
        await InvokeAsync(async () =>
        {
            if (conversationDetails?.Messages != null)
            {
                // Check if this message belongs to the current conversation
                if (message.BotFrameworkConversationId == ConversationId || 
                    message.ConversationId.ToString() == ConversationId)
                {
                    Console.WriteLine($"[ConversationDetail] ✅ Message belongs to current conversation: {message.Content}");
                    conversationDetails.Messages.Add(message);
                    Console.WriteLine($"[ConversationDetail] ✅ Message added to list. Total messages: {conversationDetails.Messages.Count}");
                    
                    // Check if user is near bottom for auto-scroll
                    var shouldScroll = false;
                    try
                    {
                        shouldScroll = await JSRuntime.InvokeAsync<bool>("conversationRealtime.isNearBottom", "messages-container");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[ConversationDetail] Failed to check isNearBottom: {ex.Message}");
                        // Default to true to ensure auto-scroll when JS function is not available
                        shouldScroll = true;
                    }
                    
                    StateHasChanged();
                    
                    if (shouldScroll)
                    {
                        Console.WriteLine($"[ConversationDetail] Auto-scrolling to bottom");
                        await ScrollToBottom();
                    }
                    else
                    {
                        Console.WriteLine($"[ConversationDetail] User not at bottom, not auto-scrolling");
                    }
                    
                    // Handle notifications if page is not visible
                    if (!await IsPageVisible())
                    {
                        _unreadMessages++;
                        await UpdateBrowserTitle();
                        await PlayNotificationSound();
                    }
                }
                else
                {
                    Console.WriteLine($"[ConversationDetail] Ignoring message for different conversation: {message.BotFrameworkConversationId} vs {ConversationId}");
                }
            }
            else
            {
                Console.WriteLine("[ConversationDetail] conversationDetails.Messages is null");
            }
        });
    }

    private async Task OnConversationStatusChanged(string conversationId, ConversationStatus status)
    {
        if (conversationId == ConversationId)
        {
            await InvokeAsync(async () =>
            {
                if (conversationDetails != null)
                {
                    conversationDetails.Conversation.Status = status;
                    StateHasChanged();
                    Snackbar.Add($"Conversation status changed to {status}", Severity.Info);
                }
            });
        }
    }

    private async Task OnCustomerTyping(string conversationId, bool isTyping)
    {
        if (conversationId == ConversationId)
        {
            await InvokeAsync(() =>
            {
                _customerTyping = isTyping;
                StateHasChanged();
                
                // Auto-hide typing indicator after 5 seconds
                if (isTyping)
                {
                    _typingTimer?.Dispose();
                    _typingTimer = new Timer(5000);
                    _typingTimer.Elapsed += (s, e) =>
                    {
                        InvokeAsync(() =>
                        {
                            _customerTyping = false;
                            StateHasChanged();
                            _typingTimer?.Dispose();
                        });
                    };
                    _typingTimer.AutoReset = false;
                    _typingTimer.Start();
                }
            });
        }
    }

    private async Task OnAgentJoinedConversation(string conversationId, string agentId, string agentName)
    {
        if (conversationId == ConversationId)
        {
            await InvokeAsync(() =>
            {
                var existing = _conversationViewers.FirstOrDefault(v => v.UserId == agentId);
                if (existing == null)
                {
                    _conversationViewers.Add(new ConversationViewerDto
                    {
                        UserId = agentId,
                        UserName = agentName,
                        DisplayName = agentName,
                        JoinedAt = DateTime.UtcNow,
                        IsCurrentUser = false
                    });
                    StateHasChanged();
                }
            });
        }
    }

    private async Task OnAgentLeftConversation(string conversationId, string agentId)
    {
        if (conversationId == ConversationId)
        {
            await InvokeAsync(() =>
            {
                _conversationViewers.RemoveAll(v => v.UserId == agentId);
                StateHasChanged();
            });
        }
    }

    private async Task OnConversationViewersUpdated(string conversationId, List<ConversationViewerDto> viewers)
    {
        if (conversationId == ConversationId)
        {
            await InvokeAsync(() =>
            {
                _conversationViewers = viewers;
                StateHasChanged();
            });
        }
    }

    private async Task OnConversationAssigned(int conversationId, string agentId, string agentName)
    {
        if (conversationId.ToString() == ConversationId)
        {
            await InvokeAsync(async () =>
            {
                await LoadConversation();
                StateHasChanged();
                Snackbar.Add($"Conversation assigned to {agentName}", Severity.Info);
            });
        }
    }

    private async Task OnConversationCompleted(int conversationId, string agentId)
    {
        if (conversationId.ToString() == ConversationId)
        {
            await InvokeAsync(async () =>
            {
                await LoadConversation();
                StateHasChanged();
                Snackbar.Add("Conversation has been completed", Severity.Info);
            });
        }
    }

    private async Task HandleNewMessage(string message)
    {
        try
        {
            _sendingMessage = true;
            StateHasChanged();
            
            // Scroll to bottom to show the new message
            await ScrollToBottom();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling new message: {ex.Message}");
        }
        finally
        {
            _sendingMessage = false;
            StateHasChanged();
        }
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("conversationRealtime.scrollToBottom", "messages-container");
        }
        catch
        {
            // Ignore JS errors
        }
    }

    // New helper methods for real-time features
    private void UpdateConnectionStatus(string status)
    {
        (_connectionStatus, _connectionColor, _connectionIcon) = status switch
        {
            "connected" => ("Connected", Color.Success, Icons.Material.Filled.CheckCircle),
            "reconnecting" => ("Reconnecting...", Color.Warning, Icons.Material.Filled.Sync),
            "disconnected" => ("Disconnected", Color.Error, Icons.Material.Filled.Error),
            "error" => ("Connection Error", Color.Error, Icons.Material.Filled.Error),
            _ => ("Unknown", Color.Default, Icons.Material.Filled.Help)
        };
        
        InvokeAsync(StateHasChanged);
    }

    private async Task UpdateBrowserTitle()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("conversationRealtime.updateTabTitle", _originalTitle, _unreadMessages);
        }
        catch
        {
            // Ignore JS errors
        }
    }

    private async Task PlayNotificationSound()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("conversationRealtime.playNotificationSound");
        }
        catch
        {
            // Ignore JS errors
        }
    }

    private async Task<bool> IsPageVisible()
    {
        try
        {
            return await JSRuntime.InvokeAsync<bool>("eval", "!document.hidden");
        }
        catch
        {
            return true; // Assume visible if we can't check
        }
    }

    private void JoinConversationViewers()
    {
        try
        {
            // In a real implementation, you might call a command to track viewers
            // For now, we'll just add ourselves to the local viewers list
            var currentUserId = "current-user"; // You'd get this from user context
            var currentUserName = "Current Agent"; // You'd get this from user context
            
            _conversationViewers.Add(new ConversationViewerDto
            {
                UserId = currentUserId,
                UserName = currentUserName,
                DisplayName = currentUserName,
                JoinedAt = DateTime.UtcNow,
                IsCurrentUser = true
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error joining conversation viewers: {ex.Message}");
        }
    }

    private async Task OpenWrapupDialog()
    {
        if (conversationDetails?.Conversation.Status == ConversationStatus.Completed)
        {
            Snackbar.Add(L["This conversation is already completed"], Severity.Warning);
            return;
        }

        var parameters = new DialogParameters
        {
            { nameof(ConversationWrapupDialog.ConversationId), ConversationId }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            MaxWidth = MaxWidth.Medium,
            FullWidth = true,
            CloseOnEscapeKey = true
        };

        var dialog = await DialogService.ShowAsync<ConversationWrapupDialog>(
            L["Complete Conversation"], 
            parameters, 
            options);

        var result = await dialog.Result;
        
        if (result != null && !result.Canceled)
        {
            // Refresh the conversation details to show the updated status
            await LoadConversation();
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            _typingTimer?.Dispose();
            
            if (_hubConnection != null)
            {
                // Dispose only handlers registered by this component (won't affect NotificationIndicator or others)
                _newMessageReceivedHandler?.Dispose();
                _conversationStatusChangedHandler?.Dispose();
                _customerTypingHandler?.Dispose();
                _agentJoinedHandler?.Dispose();
                _agentLeftHandler?.Dispose();
                _conversationViewersUpdatedHandler?.Dispose();
                _legacyConversationAssignedHandler?.Dispose();
                _legacyConversationCompletedHandler?.Dispose();
                
                // Leave conversation group but don't dispose the shared connection
                // NOTE: Intentionally NOT leaving the conversation group here to allow the global
                // NotificationIndicator component to continue receiving NewMessageReceived group
                // events after navigating away from the detail page. Leaving the group here was
                // causing loss of off-page notifications. Group membership will now be released
                // when the conversation is completed (handled in NotificationIndicator) or via
                // future explicit cleanup logic if needed.
                // await _hubConnection.InvokeAsync("LeaveConversationGroup", ConversationId);
            }
            
            // Reset browser title
            await JSRuntime.InvokeVoidAsync("conversationRealtime.updateTabTitle", _originalTitle, 0);
        }
        catch
        {
            // Ignore cleanup errors
        }
        
        GC.SuppressFinalize(this);
    }
    
    private async Task HandleTransferCompleted(bool transferred)
    {
        if (transferred)
        {
            // Refresh the conversation details to show the updated assignment
            await LoadConversation();
            StateHasChanged();
            Snackbar.Add(L["Conversation has been transferred successfully"], Severity.Success);
        }
    }
}

<script src="~/js/conversations.js"></script>
<script src="~/js/conversation-realtime.js"></script>
